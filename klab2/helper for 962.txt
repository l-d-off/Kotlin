Ищем куб, начинаем с 5^3 (6 перестановок).
Формируем list и set (уникальный list).
Бегаем по set и ищем количество каждого элемента в list, находим факториалы,
например для 110122 keptFactorials = 3! * 2! * 1!.
Ищем количество перестановок куба (вызываем функцию), кидаем туда
list.size - 1 (степень числа 10), чтобы проверить, не включила ли
перестановка нули спереди, например для 110 не должно быть 011.

Основная функция:
Подаём текущий куб, проверяем, есть ли у него целочисленный корень кубический.
Если list пустой
{
если есть корень кубический и число при делении на 10^(list.size - 1) != 0,
тогда возвращаем 1 (подходит), в остальных случаях 0 (не подходит)
{
иначе
{
Бегаем по текущему в рекурсии list путём foreach,
формируем текущий куб и идём в рекурсию без it-элемента.
Когда идём ко дну рекурсии (list.isEmpty()), то текущий куб окончательно формируется.
В foreach countOfPermutation складывает значение рекурсии для каждого it, таким образом
считаются нужные перестановки.
}
На первом вызове возвращается countOfPermutation (после всех вычислений).

ОТВЕТ (но очень долго вычисляет, поэтому проверим на трёх перестановках):
The smallest cube with 5 permutations is 127035954683
Made from 5027^3